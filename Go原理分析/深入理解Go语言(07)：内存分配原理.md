## 一、Linux系统内存

在说明golang内存分配之前，先了解下Linux系统内存相关的基础知识，有助于理解golang内存分配原理。

### 1.1 虚拟内存技术

在早期内存管理中，如果程序太大，超过了空闲内存容量，就没有办法把全部程序装入到内存，这时怎么办？ 在许多年前，人们采用了一种叫做覆盖技术，这样一种解决方案。

这是一种什么样的解决方案？
就是把程序分为若干个部分，称为覆盖块（overlay），核心思想就是分解（跟现代架构技术中分解、分模块思想很相近）。然后只把那些需要用到的指令和数据保存在内存中，而把其余的指令和数据保存在内存外。关键是需要程序员手动来分块。

这种技术有什么问题呢？
这种技术必须由程序员手工把一个大的程序划分为若干个小的功能模块，并确定各个模块之间的调用关系。手工做这种事情很费时费力，使得编程复杂度增加。但是，程序员总是爱“偷懒”的，于是，人们去寻找更好的方案。

这个方案就是虚拟内存技术，它的基本思路：
程序运行进程的总大小可以超过实际可用的物理内存的大小。每个进程都可以有自己独立的虚拟地址空间。然后通过CPU和MMU把虚拟内存地址转换为实际物理地址。

这个就相当于在物理内存和程序之间增加了一个中间层，虚拟内存。
虚拟存储也可以看作是对内存的一种抽象。而且这种抽象带来诸多好处：
1. 它将内存看成是一个存储在磁盘上的地址空间的高速缓存，在内存中只保留了活动区域，可以根据需要在磁盘和内存间来回传送数据，高效使用内存。
2. 它为每个进程提供了一致的地址空间，简化了存储的管理。
3. 对进程起到保护作用，不被其他进程地址空间破坏，因为每个进程的地址空间都是相互独立。

（程序：静态的程序；进程：动态的，可以看作是程序的一个实例）

坏处：就是复杂度进一步增加，这也是必然的。不过相比带来的好处，复杂度的增加还是可以接受，并克服。

Linux中对进程的处理抽象成了一个结构体 `task_struct`，我前面文章有对这个[结构体的介绍](https://www.cnblogs.com/jiujuan/p/11715853.html)。下面就看看进程的内存。

### 1.2 进程的内存

进程内存在linux（32位）中的布局：
![linux-32bit-mem-process-allocate](../images/linux-32bit-mem-process-allocate-img.png)


> 来自：https://manybutfinite.com/post/anatomy-of-a-program-in-memory/

最高位的1GB是linux内核空间，用户代码不能写，否则触发段错误。下面的3GB是进程使用的内存。

>Kernel space：linux内核空间内存
>Stack：进程栈空间，程序运行时使用。它向下增长，系统自动管理
>Memory Mapping Segment：内存映射区，通过mmap系统调用，将文件映射到进程的地址空间，或者匿名映射。
>Heap：堆空间。这个就是程序里动态分配的空间。linux下使用malloc调用扩展（用brk/sbrk扩展内存空间），free函数释放（也就是缩减内存空间）
>BSS段：包含未初始化的静态变量和全局变量
>Data段：代码里已初始化的静态变量、全局变量
>Text段：代码段，进程的可执行文件

## 二、内存管理中的一些常见问题

1、未能释放已经不再使用的内存 - 内存泄漏
2、指向不可用的内存指针 - 野指针
3、指针所指向的对象已经被回收了，但是指向该对象的指针仍旧指向已经回收的内存地址 - 悬挂指针
4、分配或释放内存太快或者太慢
5、分配内存大小不合理，造成内存碎片问题
6、内存碎片问题

## 三、TCMalloc

可以查看前面的文章 [TCMalloc内存分配简析](https://www.cnblogs.com/jiujuan/p/13869547.html)，TCMalloc内存分配器的原理和golang内存分配器原理相近，所以理解了TCMalloc，golang内存分配原理也就理解大半，不过golang对它也有一些改动。

## 四、golang内存

### 4.1 golang怎么解决常见内存问题

golang是怎么解决 `二`  的内存管理中的常见问题的呢？

针对上面的1、2、3 这三种问题，golang使用自动垃圾回收机制，一般情况下，都不使用指针运算（要运算用unsafe包），很少的指针使用。当然，内存泄漏问题不能完全根除，但是可以解决一大部分问题。

针对下面的4、5、6 这三种问题，golang采用了多级缓存，预分配的方法，来加快内存分配和释放回收，尽量减少内存碎片。详见 [TCMalloc内存分配简析](https://www.cnblogs.com/jiujuan/p/13869547.html) 。

### 4.2 为什么要重新写一个内存分配器

内核已经有一个malloc的内存分配器，为什么还有重写一个内存分配器？

可以看到，malloc是一个很悠久的内存分配器，但是随着时代的发展，多核多线程已经普及，为了更好的应用多线程，提高程序效率，以及改进内存碎片，所以重新写了一个内存分配器。从这里 [TCMalloc内存分配简析](https://www.cnblogs.com/jiujuan/p/13869547.html) 可以看出TCMaloc的优点，它将内存划分为多级别，减少锁的开销。而且每个线程的缓存又分开了多个小的对象，以减少内存碎片。等等优化改进。

所以go内存分配也继承了这些优点。go还有一个原因，那就是go还有GC，需要配合内存的垃圾回收。

### 4.3 内存管理到底管理哪个区域

从上面的进程内存布局图，可以看出一个进程的内存划分了好多不同的区域，而内存管理主要管理的就是Stack和Heap，其中Stack （栈）区主要由编译器和系统管理，程序语言主要管理Heap（堆），主要是语言的runtime来管理。而且这里的进程内存指的是虚拟内存。

### 4.4 golang内存分配中的概念

golang内存分配的基本思想来自[TCMalloc](https://www.cnblogs.com/jiujuan/p/13869547.html)，所以go内存分配中的几个概念与TCMalloc很相似，可以看看[TCMalloc 中的概念](https://www.cnblogs.com/jiujuan/p/13869547.html#1095668929) 。

#### mspan
mspan跟tcmalloc中的span相似，它是golang内存管理中的基本单位，也是由页组成的，每个页大小为8KB，与tcmalloc中span组成的默认基本内存单位页大小相同。mspan里面按照8*2n大小（8b，16b，32b .... ），每一个mspan又分为多个object。
就连名字也很像，mspan中的m应该是memory的第一个字母。

#### mcache
mcache跟tcmalloc中的ThreadCache相似，ThreadCache为每个线程的cache，同理，mcache可以为golang中每个Processor提供内存cache使用，每一个mcache的组成单位也是mspan。

#### mcentral
mcentral跟tcmalloc中的CentralCache相似，当mcache中空间不够用，可以向mcentral申请内存。可以理解为mcentral为mcache的一个“缓存库”，供mcaceh使用。它的内存组成单位也是mspan。
mcentral里有两个双向链表，一个链表表示还有空闲的mspan待分配，一个表示链表里的mspan都被分配了。

#### mheap
mheap跟tcmalloc中的PageHeap相似，负责大内存的分配。当mcentral内存不够时，可以向mheap申请。那mheap没有内存资源呢？跟tcmalloc一样，向OS操作系统申请。
还有，大于32KB的内存，也是直接向mheap申请。

#### 总结
golang内存分配几个相关概念，用图来总结一下：

![go-memory-allocate-mcache-mcentral-mspan](../images/go-memory-allocate-mcache-mcentral-mspan-img.png)


后面再进一步分析golang的内存分配原理。

## 五、参考
- [visualizing-memory-management-in-golang](https://deepu.tech/memory-management-in-golang/) - Deepu K Sasidharan
- [翻译版:可视化golang内存管理](https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/) - tonybai
- [《操作系统的设计与实现》](https://book.douban.com/subject/3108799/)
- [a-program-in-memory](https://manybutfinite.com/post/anatomy-of-a-program-in-memory/) linux内核分析很棒的文章